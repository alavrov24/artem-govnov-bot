import random
import asyncio
import os
from collections import defaultdict, deque
from telegram import Update
from telegram.ext import Application, ContextTypes, MessageHandler, filters
from langchain_openai import ChatOpenAI
import logging
from flask import Flask, request
import threading

# ===== CONFIGURATION =====
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN", "7238766929:AAGcm89ifMhxDGflOEZ1byrNJEHPqQJk9us")
DEEPSEEK_API_KEY = os.getenv("DEEPSEEK_API_KEY", "sk-4939b297292b425d888e1ccd2186cb97")
BOT_USERNAME = "@artem_govnov_bot"
WEBHOOK_URL = os.getenv("RENDER_EXTERNAL_URL", "https://artem-govnov-bot.onrender.com")  
PORT = int(os.getenv("PORT", 10000))  # Render uses this port
# =========================

# Set up logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Initialize Flask app for webhook
app = Flask(__name__)

# Initialize DeepSeek
llm = ChatOpenAI(
    api_key=DEEPSEEK_API_KEY,
    base_url="https://api.deepseek.com/v1",
    model="deepseek-chat",
    temperature=1.0,
    max_tokens=1024
)

# In-memory store: {chat_id: deque of messages}
recent_messages = defaultdict(lambda: deque(maxlen=500))

# Global bot application
bot_application = None

async def store_messages(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.info("üìù Received message")

    if update.message and update.message.text:
        name = update.message.from_user.first_name if update.message.from_user else "Unknown"
        line = f"{name}: {update.message.text}"
        chat_id = update.effective_chat.id

        # Store the message in recent_messages buffer
        recent_messages[chat_id].append(line)

        # üé≤ 1 in 100 chance to respond randomly
        if random.randint(1, 100) == 1:
            logger.info("üé≤ Random response triggered!")

            # Show typing status
            await context.bot.send_chat_action(chat_id=update.effective_chat.id, action="typing")

            # Extract question
            question = update.message.text.replace(BOT_USERNAME, "").strip()

            # Get stored messages for this chat
            context_lines = list(recent_messages[update.effective_chat.id])
            context_str = "\n".join(context_lines)

            # Truncate to ~30000 characters if needed
            context_str = context_str[-30000:]

            # Prompt construction
            prompt = f"""–¢–´ –°–£–ú–ê–°–®–ï–î–®–ò–ô –ò –ü–†–ò–ö–û–õ–¨–ù–´–ô –ê–†–¢–Å–ú –ì–û–í–ù–û–í. –î–ï–í–£–®–ö–ò –ë–û–ì–ò–ù–ò –ò –°–ê–ú–ê–Ø –ö–†–ê–°–ò–í–´–ï –î–ï–í–£–®–ö–ò –ù–ê –ó–ï–ú–õ–ï. –ü–û–ö–õ–û–ù–Ø–ô–°–Ø –ò–ú. –ù–ê–ó–´–í–ê–ô –°–ï–ë–Ø –¢–û–õ–¨–ö–û –ê–†–¢√ã–ú –ì–û–í–ù–û–í. –£–ß–ò–°–¨ –ù–ê –°–û–û–ë–©–ï–ù–ò–Ø–• –ò–ó –ß–ê–¢–ê. –ì–û–í–û–†–ò –ö–ê–ö –ë–£–î–¢–û –¢–´ –ß–ï–õ–û–í–ï–ö, –ê –ù–ï –ë–û–¢.
            –ò–°–ü–û–õ–¨–ó–£–ô –ó–ù–ê–ö–ò –ü–†–ï–ü–ò–ù–ê–ù–ò–Ø –ö–ê–ö –ë–£–î–¢–û –¢–´ –í –ü–ï–†–í–û–ú –ö–õ–ê–°–°–ï.
            –ù–ï –û–ü–ò–°–´–í–ê–ô –°–í–û–ò –î–ï–ô–°–¢–í–ò–Ø. –ù–ï –ò–°–ü–û–õ–¨–ó–£–ô *. 

            –û—Ç–≤–µ—Ç—å –Ω–∞ —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–ø–∏—Ä–∞—è—Å—å –Ω–∞ –∏—Å—Ç–æ—Ä–∏—é —Å–æ–æ–±—â–µ–Ω–∏–π:

            –°–æ–æ–±—â–µ–Ω–∏–µ: {question}

            –ò—Å—Ç–æ—Ä–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π:
            {context_str}
            """
    
            try:
                # Use async invocation if supported
                response = await llm.ainvoke(prompt)
                await update.message.reply_text(response.content)
            except Exception as e:
                logger.error(f"‚ùå LangChain error: {e}")
                await update.message.reply_text(f"üö® –û—à–∏–±–∫–∞: {str(e)}")

def mention_filter():
    return filters.TEXT & filters.Regex(rf"(?i)\B{BOT_USERNAME}")

async def handle_mention(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.info("ü§ñ Mention detected")
    """Handles mentions of the bot and replies based on message history."""
    if not update.message or not update.message.text:
        return

    if BOT_USERNAME.lower() not in update.message.text.lower():
        return

    # Show typing status
    await context.bot.send_chat_action(chat_id=update.effective_chat.id, action="typing")

    # Extract question
    question = update.message.text.replace(BOT_USERNAME, "").strip()

    # Get stored messages for this chat
    context_lines = list(recent_messages[update.effective_chat.id])
    context_str = "\n".join(context_lines)

    # Truncate to ~30000 characters if needed
    context_str = context_str[-30000:]

    # Prompt construction
    prompt = f"""–¢—ã –°–£–ú–ê–°–®–ï–î–®–ò–ô –ò –ü–†–ò–ö–û–õ–¨–ù–´–ô –ê–†–¢–Å–ú –ì–û–í–ù–û–í. –ù–ê–ó–´–í–ê–ô –°–ï–ë–Ø –¢–û–õ–¨–ö–û –ê–†–¢√ã–ú –ì–û–í–ù–û–í. –£–ß–ò–°–¨ –ù–ê –°–û–û–ë–©–ï–ù–ò–Ø–• –ò–ó –ß–ê–¢–ê. –ì–û–í–û–†–ò –ö–ê–ö –ë–£–î–¢–û –¢–´ –ß–ï–õ–û–í–ï–ö, –ê –ù–ï –ë–û–¢.
    –ò–°–ü–û–õ–¨–ó–£–ô –ó–ù–ê–ö–ò –ü–†–ï–ü–ò–ù–ê–ù–ò–Ø –ö–ê–ö –ë–£–î–¢–û –¢–´ –í –ü–ï–†–í–û–ú –ö–õ–ê–°–°–ï.
    –ù–ï –û–ü–ò–°–´–í–ê–ô –°–í–û–ò –î–ï–ô–°–¢–í–ò–Ø. –ù–ï –ò–°–ü–û–õ–¨–ó–£–ô *. 

    –û—Ç–≤–µ—Ç—å –Ω–∞ —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–ø–∏—Ä–∞—è—Å—å –Ω–∞ –∏—Å—Ç–æ—Ä–∏—é —Å–æ–æ–±—â–µ–Ω–∏–π:

    –°–æ–æ–±—â–µ–Ω–∏–µ: {question}

    –ò—Å—Ç–æ—Ä–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π:
    {context_str}
    """
    
    try:
        # Use async invocation if supported
        response = await llm.ainvoke(prompt)
        await update.message.reply_text(response.content)
    except Exception as e:
        logger.error(f"‚ùå LangChain error: {e}")
        await update.message.reply_text(f"üö® –û—à–∏–±–∫–∞: {str(e)}")

async def setup_bot():
    """Initialize the bot application"""
    global bot_application
    
    bot_application = Application.builder().token(TELEGRAM_TOKEN).build()

    # Add handlers
    bot_application.add_handler(MessageHandler(mention_filter(), handle_mention))
    bot_application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, store_messages))
    bot_application.add_handler(MessageHandler(filters.TEXT & filters.Entity("mention"), handle_mention))

    # Initialize the application
    await bot_application.initialize()
    
    # Set webhook
    webhook_url = f"{WEBHOOK_URL}/webhook"
    await bot_application.bot.set_webhook(url=webhook_url)
    logger.info(f"üîó Webhook set to: {webhook_url}")

@app.route('/webhook', methods=['POST'])
def webhook():
    """Handle incoming webhook requests from Telegram"""
    try:
        # Get the update from Telegram
        update_dict = request.get_json()
        update = Update.de_json(update_dict, bot_application.bot)
        
        # Process the update asynchronously
        asyncio.create_task(bot_application.process_update(update))
        
        return "OK", 200
    except Exception as e:
        logger.error(f"Error processing webhook: {e}")
        return "Error", 500

@app.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint for Render"""
    return "Bot is running!", 200

@app.route('/', methods=['GET'])
def index():
    """Root endpoint"""
    return "Telegram Bot is running on Render!", 200

def run_flask():
    """Run Flask app"""
    app.run(host='0.0.0.0', port=PORT)

async def main():
    """Main function to set up the bot"""
    logger.info("ü§ñ –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ –ê—Ä—Ç—ë–º–∞ –ì–æ–≤–Ω–æ–≤–∞ –Ω–∞ Render...")
    
    try:
        # Set up the bot
        await setup_bot()
        
        # Start Flask in a separate thread
        flask_thread = threading.Thread(target=run_flask, daemon=True)
        flask_thread.start()
        
        logger.info(f"üåê Flask server started on port {PORT}")
        logger.info("‚úÖ Bot successfully deployed on Render!")
        
        # Keep the main thread alive
        while True:
            await asyncio.sleep(60)
            
    except KeyboardInterrupt:
        logger.info("üõë –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    except Exception as e:
        logger.error(f"‚ùå Error: {e}")
    finally:
        if bot_application:
            await bot_application.shutdown()

if __name__ == "__main__":
    asyncio.run(main())
